# Docker Compose file version. Version 3.8 is widely compatible.
version: '3.8'

# Defines the services (containers) that make up your application.
services:
  # Defines the 'app' service, which is our main application container.
  app:
    # Specifies how to build the image for this service.
    build:
      # The build context is the current directory (project root).
      context: .
      # Specifies the Dockerfile to use for building the image.
      dockerfile: Dockerfile
      # Build arguments can be passed to the Dockerfile.
      # Example: To use a specific base image for GPU support (see Dockerfile ARGs).
      # args:
      #   BASE_IMAGE: nvidia/cuda:11.8.0-cudnn8-devel-ubuntu22.04
      #   FINAL_BASE_IMAGE: nvidia/cuda:11.8.0-cudnn8-runtime-ubuntu22.04
    
    # Sets a custom container name for easier identification.
    container_name: qlop_app_container
    
    # Optionally, specify an image name if you want Docker Compose to tag the image it builds.
    # image: your_username/qlop_app:latest

    # Environment variables to set inside the container.
    # These can be used to configure the application without rebuilding the image.
    # `PYTHONUNBUFFERED=1` ensures that Python output (print statements, logs) is sent directly
    # to the terminal without being buffered, which is useful for debugging.
    environment:
      - PYTHONUNBUFFERED=1 
      # - APP_ENV=development # Example: set application environment
      # - LOG_LEVEL=DEBUG # Example: override log level
      # - NEWS_API_KEY=${NEWS_API_KEY} # Pass secrets from host environment or .env file

    # Use an .env file to manage environment variables, especially secrets.
    # Create a .env file in the project root (and add it to .gitignore).
    # Example .env file content:
    # NEWS_API_KEY=your_actual_news_api_key
    # ALPHA_VANTAGE_API_KEY=your_actual_alpha_vantage_key
    env_file:
      - .env # Docker Compose will look for a file named .env in the project root

    # Volumes mount host directories or named volumes into the container.
    # This is crucial for development to see code changes live without rebuilding.
    # For production, you typically bake the code into the image and might use named volumes for persistent data.
    volumes:
      # Mounts the entire project directory on the host to /app in the container.
      # Changes made to the code on the host are immediately reflected in the container.
      - .:/app
      
      # Example: Persist data that the application generates or needs.
      # These could be named volumes or host mounts.
      # Named volumes are managed by Docker and are preferred for data persistence.
      # - app_data:/app/data             # Mounts a named volume 'app_data' to /app/data
      # - app_models:/app/models         # Mounts a named volume 'app_models' to /app/models
      # - app_logs:/app/logs             # Mounts a named volume 'app_logs' to /app/logs
      # Alternatively, use host mounts if you want direct access on the host:
      # - ./data:/app/data
      # - ./models:/app/models
      # - ./logs:/app/logs

    # Ports mapping: <host_port>:<container_port>
    # Expose ports if your application runs a web service (e.g., API or Streamlit GUI).
    # If not running a server, this section might not be needed.
    # ports:
    #   # Example for Streamlit (if running `streamlit run gui.py`)
    #   - "8501:8501"
    #   # Example for a FastAPI/Flask API (if running `uvicorn api.main:app --host 0.0.0.0 --port 8000`)
    #   - "8000:8000"

    # Entrypoint and Command:
    # The Dockerfile defines the default ENTRYPOINT and CMD.
    # `entrypoint` in docker-compose overrides the Dockerfile's ENTRYPOINT.
    # `command` in docker-compose overrides the Dockerfile's CMD.
    # Our Dockerfile uses an entrypoint.sh script, so these can usually be left commented out
    # unless specific overrides are needed for this compose file.
    # entrypoint: ["/app/entrypoint.sh"] # Matches Dockerfile
    # command: ["python", "main.py", "--help"] # Default command passed to entrypoint.sh

    # For development, keeping the container running even if the default command exits can be useful.
    # `tty: true` allocates a pseudo-TTY.
    # `stdin_open: true` keeps STDIN open.
    # This allows `docker exec -it qlop_app_container bash`.
    tty: true
    stdin_open: true

    # Healthcheck: Uses the HEALTHCHECK instruction defined in the Dockerfile.
    # No need to redefine here unless you want to override the Dockerfile's healthcheck.

# Defines custom networks. By default, Docker Compose creates a bridge network for all services in the file.
networks:
  default:
    driver: bridge # Default network driver

# Defines named volumes. These are managed by Docker and are useful for persisting data
# generated by or used by Docker containers, independent of the container lifecycle.
# volumes:
#   app_data: # Data generated/used by the app (e.g., downloaded datasets, processed features)
#   app_models: # Trained models
#   app_logs: # Application logs
