import ast
import os
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import re # For response model name extraction

# Add project root to sys.path to allow importing project modules if absolutely necessary,
# but the goal is to use AST parsing primarily.
project_root = Path(__file__).resolve().parent.parent
# sys.path.insert(0, str(project_root)) # Avoid if possible to prevent dependency issues

MODELS_FILE_PATH = project_root / "api" / "models.py"
CONTROLLERS_FILE_PATH = project_root / "api" / "controllers.py"
OUTPUT_FILE_PATH = project_root / "docs" / "api.md"

def parse_pydantic_model(node: ast.ClassDef) -> Optional[Dict[str, Any]]:
    """Parses a Pydantic model class definition using AST."""
    if not any(isinstance(base, ast.Name) and base.id == 'BaseModel' for base in node.bases):
        # Consider also checking for pydantic.BaseModel if import alias is used
        return None

    model_info: Dict[str, Any] = {"name": node.name, "fields": [], "docstring": ast.get_docstring(node)}
    
    for item in node.body:
        if isinstance(item, ast.AnnAssign):
            field_name = item.target.id if isinstance(item.target, ast.Name) else "unknown"
            
            field_type_str = ""
            if item.annotation:
                if hasattr(ast, 'unparse'): 
                    field_type_str = ast.unparse(item.annotation)
                else: 
                    field_type_str = "ComplexType (View Source)" 
                    if isinstance(item.annotation, ast.Name):
                        field_type_str = item.annotation.id
                    elif isinstance(item.annotation, ast.Subscript):
                        if isinstance(item.annotation.value, ast.Name):
                            field_type_str = f"{item.annotation.value.id}[...]"

            is_optional = "Optional[" in field_type_str or field_type_str.startswith("Optional[")
            
            description = ""
            default_value_repr = "N/A (Required)"
            if item.value: 
                if hasattr(ast, 'unparse'):
                    default_value_repr = ast.unparse(item.value)
                else:
                    default_value_repr = "DefaultValue (View Source)"

                if "Field(" in default_value_repr:
                    if isinstance(item.value, ast.Call) and isinstance(item.value.func, ast.Name) and item.value.func.id == 'Field':
                        for kw in item.value.keywords:
                            if kw.arg == 'description' and isinstance(kw.value, ast.Constant):
                                description = kw.value.value
                            if kw.arg == 'default': 
                                default_value_repr = ast.unparse(kw.value) if hasattr(ast, 'unparse') else "DefaultValue"
                                is_optional = True 
                            elif kw.arg == 'default_factory': 
                                default_value_repr = f"Generated by {ast.unparse(kw.value) if hasattr(ast, 'unparse') else 'default_factory'}"
                                is_optional = True

            model_info["fields"].append({
                "name": field_name,
                "type": field_type_str,
                "optional": is_optional,
                "default": default_value_repr if is_optional or "Field(" in default_value_repr else "Required",
                "description": description
            })
        elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Constant) and isinstance(item.value.value, str):
            pass # Class-level docstring if not parsed by get_docstring

    return model_info

def parse_controller_function(node: ast.FunctionDef) -> Dict[str, Any]:
    """Parses a controller function definition using AST."""
    func_info = {
        "name": node.name,
        "docstring": ast.get_docstring(node) or "No description provided.",
        "params": [],
        "request_model_name": None, 
        "response_model_name": None 
    }
    for arg_node in node.args.args:
        param_name = arg_node.arg
        param_type_str = ""
        if arg_node.annotation:
            if hasattr(ast, 'unparse'):
                param_type_str = ast.unparse(arg_node.annotation)
            elif isinstance(arg_node.annotation, ast.Name):
                 param_type_str = arg_node.annotation.id
        
        func_info["params"].append({"name": param_name, "type": param_type_str})
        
        if len(func_info["params"]) == 1 and param_type_str and param_type_str != "dict":
            if "ApiRequest" in param_type_str : # Simple inference
                 func_info["request_model_name"] = param_type_str.split('[')[0] if '[' in param_type_str else param_type_str


    if node.returns:
        if hasattr(ast, 'unparse'):
            return_type_str = ast.unparse(node.returns)
            match = re.search(r"(\w*ApiResponse)\b", return_type_str) # Look for ClassNameApiResponse pattern
            if match: 
                func_info["response_model_name"] = match.group(1)
        
    return func_info


def generate_api_markdown(controllers: List[Dict[str, Any]], models: Dict[str, Dict[str, Any]]) -> str:
    """Generates Markdown documentation for the API."""
    md_lines = ["# API Reference", ""]

    md_lines.append("## Endpoints")
    for func in sorted(controllers, key=lambda x: x['name']): # Sort controllers alphabetically
        endpoint_path = func['name'].replace('_controller', '').replace('_', '-') # basic path generation
        md_lines.append(f"### `POST /{endpoint_path}`") 
        md_lines.append(f"**Controller Function:** `{func['name']}`")
        md_lines.append("")
        md_lines.append(f"**Description:** {func['docstring']}")
        md_lines.append("")

        req_model_name = func.get("request_model_name")
        if isinstance(req_model_name, str) and req_model_name in models:
            md_lines.append("**Request Body:**")
            md_lines.append("")
            model = models[req_model_name]
            md_lines.append(f"- **Type:** `{model['name']}`")
            if model.get('docstring'): md_lines.append(f"- **Description:** {model['docstring']}")
            if model["fields"]:
                md_lines.append("- **Fields:**")
                for field in model["fields"]:
                    default_info = f"(Optional, Default: `{field['default']}`)" if field['optional'] and field['default'] != 'N/A (Required)' else "(Required)"
                    if "Field(" in str(field['default']) and not field['optional'] : default_info = "(Required, see model definition for Field details)"
                    md_lines.append(f"  - `{field['name']}` (`{field['type']}`): {field['description'] or ''} {default_info}")
            md_lines.append("")
        elif func['params'] and func['params'][0]['type'] == 'dict':
             md_lines.append("**Request Body:** JSON object (`dict`). See controller implementation for expected structure.")
             md_lines.append("")
        
        resp_model_name = func.get("response_model_name")
        if isinstance(resp_model_name, str) and resp_model_name in models:
            md_lines.append("**Success Response Body (Example - 200 OK):**")
            md_lines.append("")
            model = models[resp_model_name]
            md_lines.append(f"- **Type:** `{model['name']}`")
            if model.get('docstring'): md_lines.append(f"- **Description:** {model['docstring']}")
            if model["fields"]:
                md_lines.append("- **Fields:**")
                for field in model["fields"]:
                     md_lines.append(f"  - `{field['name']}` (`{field['type']}`): {field['description'] or ''} {'(Optional)' if field['optional'] else ''}")
            md_lines.append("")
        else:
            md_lines.append("**Success Response Body (Example - 200 OK):** Varies. See controller implementation (typically includes `status`, `message`).")
            md_lines.append("")
            
        md_lines.append("**Error Responses:** Standard error responses (e.g., 400, 404, 422, 500) use the `ApiErrorResponse` model structure (see below).")
        md_lines.append("\n---\n")

    md_lines.append("## Data Models (Pydantic)")
    for model_name, model_data in sorted(models.items()):
        md_lines.append(f"### `{model_name}`")
        if model_data.get('docstring'): md_lines.append(f"{model_data['docstring']}")
        md_lines.append("")
        if not model_data["fields"]:
            md_lines.append("This model has no explicitly defined fields (it might be a simple status/message model or used as a generic container).")
            md_lines.append("")
            continue

        md_lines.append("| Field | Type | Optional | Default / Description |")
        md_lines.append("|-------|------|----------|-----------------------|")
        for field in model_data["fields"]:
            optional_str = "Yes" if field["optional"] else "No"
            
            # Refine default/description presentation
            desc_parts = []
            if field.get('description'): desc_parts.append(field['description'])
            
            default_display = field['default']
            if default_display == "N/A (Required)" and not field['optional']:
                 pass # Handled by Optional column
            elif "Field(" in str(default_display) and not field['optional']:
                 desc_parts.append("Field details defined in model.")
            elif field['optional']:
                 desc_parts.append(f"Default: `{default_display}`")
            
            full_desc = ". ".join(filter(None, desc_parts)) if desc_parts else "N/A"

            md_lines.append(f"| `{field['name']}` | `{field['type']}` | {optional_str} | {full_desc} |")
        md_lines.append("")

    return "\n".join(md_lines)


if __name__ == "__main__":
    parsed_models = {}
    parsed_controllers = []

    try:
        with open(MODELS_FILE_PATH, "r", encoding="utf-8") as f_models:
            models_tree = ast.parse(f_models.read())
        for node in models_tree.body:
            if isinstance(node, ast.ClassDef):
                model_info = parse_pydantic_model(node)
                if model_info:
                    parsed_models[model_info["name"]] = model_info
    except FileNotFoundError:
        print(f"Error: Models file not found at {MODELS_FILE_PATH}")
    except Exception as e:
        print(f"Error parsing models file: {e}")

    try:
        with open(CONTROLLERS_FILE_PATH, "r", encoding="utf-8") as f_ctrl:
            controllers_tree = ast.parse(f_ctrl.read())
        for node in controllers_tree.body:
            if isinstance(node, ast.FunctionDef):
                if node.name.endswith("_controller"): # Basic filter
                    func_info = parse_controller_function(node)
                    parsed_controllers.append(func_info)
    except FileNotFoundError:
        print(f"Error: Controllers file not found at {CONTROLLERS_FILE_PATH}")
    except Exception as e:
        print(f"Error parsing controllers file: {e}")

    if parsed_controllers or parsed_models:
        api_docs_markdown = generate_api_markdown(parsed_controllers, parsed_models)
        
        OUTPUT_FILE_PATH.parent.mkdir(parents=True, exist_ok=True)
        try:
            with open(OUTPUT_FILE_PATH, "w", encoding="utf-8") as f_out:
                f_out.write(api_docs_markdown)
            print(f"Successfully generated API documentation at: {OUTPUT_FILE_PATH}")
        except IOError as e:
            print(f"Error writing API documentation to {OUTPUT_FILE_PATH}: {e}")
    else:
        print("No controllers or models found to document.")
        # Create an empty file or a file with a placeholder message if nothing was parsed
        OUTPUT_FILE_PATH.parent.mkdir(parents=True, exist_ok=True)
        try:
            with open(OUTPUT_FILE_PATH, "w", encoding="utf-8") as f_out:
                f_out.write("# API Reference\n\nNo API controllers or Pydantic models found to document.\n")
            print(f"Generated a placeholder API documentation file as no content was parsed: {OUTPUT_FILE_PATH}")
        except IOError as e:
            print(f"Error writing placeholder API documentation to {OUTPUT_FILE_PATH}: {e}")
